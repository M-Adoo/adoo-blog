---
title: 哈希表（1）
date: 2011-11-08 22:18
categories: Introduction to Algorithm -third edition
tags: hash tables, 算法导论, 散列表, 笔记
override_permailink: /algorithm/introductiontoalgorithm/哈希表（1）
mathjax: true
---

### 直接寻址表（Direct-address tables）

假设有一组元素，每个元素的Key值都包含在范围U={0,1,2,3,…m-1}中。如果这个
值m不是太大，且这一组元素的Key值都不相同，我们用key值来直接决定元素或指
向元素指针的存储位置（slot,我将其翻译为位置而不是狭缝，槽或…），这就是直
接寻址表。如下图：

![direct-address-tables][]

从左图看到，对于一个元素Key值为2的元素，指向它的指针被存储在下标为2的位
置中。key值为3的被存储在小标为三的位置…

你也可以直接将元素存储在直接寻址表中，而不是存储它的指针。这一切视情况而
定，比方当元素的附属数据比较多的情况下，我想存储它的指针应该更为合理；反
之，存储元素本身应该更易管理。

直接寻指表虽然有逻辑简单，查询存储速度快等优点，但缺点也显而易见：假如U的
范围非常大的话，那么建一张这样的直接寻址表的话，不知需内存几何？另外，对
于一个U的范围偏大，而实际的元素个数又很少的话，其内存的利用率就令人发指了。
再暴力点，直接给它两个key相同的元素呢？

…于是我们就引出了哈希表。

### 哈希表（Hash tables）

与直接寻址表Key为k的元素存储在位置k不同，哈希表让Key为k的元素存储在位置为
h(k)的位置。我们将h称为哈希函数，将h(k)称为哈希值。而恰是这么一种规则，使
得哈希表的大小往往远远小于U的范围大小。因为我们可以定义一个函数值的范围比
较适合的哈希函数嘛。再看一张图：

![][1]

可以看到上图并非是直接映射，而是按照一定的规则令来映射Key值,这个规则当然就
是哈希函数。

不过可以看到，哈希函数同时带来了一个问题，那就是两个或多个不同的Key有可能被
映射到同一个位置，我们把这一问题称为碰撞（collision）,下篇文章会给出解决方
案。其实左图中已经给出了一种解决方案——用链表来解决。

### 哈希函数

一个好的哈希函数：每一个key都有相等几率哈希到哈希表中m个位置中的一个，独立
于任何其它已哈希的Key。但这仅是一种理想情况，难以把握。尽可能的使不同的key
哈希到同一个位置。

key的转换，大部分情况下，我们都是用自然数来作为Key,假如我们的key不是自然数，
我们将使用某种方法将它转化为自然数。比如如果key=”pt”可以利用它的ASCALL码将
其转换为自然数，比方p(112)+t(116)*2=344.

下面介绍的三种函数，前两种(除法哈希法，乘法哈希法)为启发式函数（heuristic
function）,第三种（全域哈希法）使用随机技术。实际应用中我们往往使用启发式
函数。

#### 除法哈希

如果我们要把一个Key为k的元素映射到大小为m的哈希表中去，则可以利用m除k的余数
来确定位置。那么哈希函数就是：h(k)=*k*mod*m*。

关于m的选择我们应当避免一些值，置于这些值是什么，算法导论没有指出，但给了我
们一个不错的例子：

比方，m不应当是2的幂，因为若\\(m = 2^p\\),那么h(k)仅仅是k的低p位，也就是说k的哈希值
仅依赖于k的低p位而与其他位没有关系。除非低p位的各种排列概率相等，否则最好选择
使得哈希值依赖于k的所有位的数。不错的选择是选一个与2的整数次幂不太接近的整数，
至于为什么，有待证明。

#### 乘法哈希

乘法哈希则是令key与一个常小数A(0<A<1)相乘，取其小数部分再与m相乘来获取Key在大
小为m的哈希表中的位置。哈希函数为：*h*(*k*)= ⌊*m*(*kA* mod 1)⌋。

乘法哈希有一个好处是，对于m的选值没有太多的要求。CLRS说一般选择一个值为2的幂的
数，究其原因在于，这样方便实现在大部分计算机上实现哈希函数，我相信对于任何一种
高级语言实现这样的哈希函数都非常简单，所以这一点，谁管他！

虽然最佳的A值与数据的特征有关，但是Knuth说![][2]是个不错的值，但其原因，我是想
管管不了，估计需要查一番资料，别深究。

#### 全域哈希（Universal hashing）

假使我们的对手已经模特了我们的哈希规则，很好，它将选择一组数,使得这一组数全部映
射到同一位置，这就操蛋了。我们虽有办法解决碰撞的问题（下一篇文章会讲到），但是哈
希表的效率将大打折扣，哈希表将变成链表，甚至更慢，完全失去了它的查找优势。问题在
于任何一个哈希函数都会有这样一种最坏情况，要彻底解决这个问题并不容易，唯一有效的
办法是，我们随机的选一个哈希函数，使之独立于key，这就是全域哈希。

其基本思想是，在执行之前随即地从一组哈希函数中选择一个作为哈希函数使用。

#### 设计全域哈希函数类

选一个够大的质数p,且p大于任意一个key。另有两系数a∈{0, 1, ..., *p* - 1},
b∈{1, 2, ..., *p* - 1}.

哈希函数为对于任意的a,b可以组成p(p-1)个不同的哈希函数中一个。OK.

本文参考： Introduction To Algorithm ——third edition

[direct-address-tables]: http://www.roading.org/images/2011-11/image_thumb.png
[1]: http://www.roading.org/images/2011-11/image9_thumb.png
[2]: http://www.roading.org/images/2011-11/image4.png
