---
title: 哈希表（Hash Tables）（2）
date: 2011-11-09 15:59
categories: Introduction to Algorithm -third edition
tags:
    - hash tables
    - 算法导论
    - 笔记
override_permailink: /algorithm/introductiontoalgorithm/哈希表（hash-tables）（2）
mathjax: true
---

### 解决碰撞

解决碰撞无非两种思路：使得一个位置能存储多个元素，此其一；不限定一个元素
只能存储到一个位置，既然要去到地方挤不下，那便换个地方，此其二。下文给出
对应两种思路将的两种方法。

### 用链表解决碰撞

既然要使得一个位置能存储多个元素，我们便将要存储到这一位置的多个元素串成
链表，并存储链表头，是为链表解决碰撞法。如图：

![][links]

这个方法简单明了，但是效率方面可能要打折扣，如果碰巧诸君不走运，一组元素
全哈希到了一个位置，全被放到一个链表中，查找的效率必然可怜（O(n)）。退一
步，只要是哈希的不太平均，那么查找的效率也让人有些难受。

### 开放地址（Open addressing）解决碰撞

开放地址法意味着:所有的元素都被存储在哈希表中,没有链表,没有存储在哈希表之
外的元素；更少的内存，更高的内存利用率——开放地址意味着填满哈希表，另外完全
逃离了指针，意味着节省了一笔空间，要明白对于一个很大的哈希表来说，如果使用
指针（链表）来解决碰撞，意味着存储指针的空间也非常可观；潜在有更快的查找速
度，更少的碰撞的可能（当然这只是潜能）。

实现开放地址的插入（叫存储更合适一些吧），首先要连续探查哈希表，直到找到一
个为空的位置来放入要插入的数。可想而知这个探查的顺序我们不可能1,2,3,…这样按
顺序来探查，这样的话效率怎么可能高的起来，探查的顺序依赖于要插入的Key。把哈
希函数扩展到多一个参数——h(key,n)。n表示第n次探查。于是可以有一个序列，来表
示要插入的Key k可以放入的位置的顺序：
〈*h*(*k*,0),*h*(*k*,1), ..., *h*(*k*,*m* - 1)〉 ——称之为探查序列。

假如函数的选择得当,那么k有机会放到每一个位置，也就是说只要哈希表未满，就可以
插入。看一下插入的伪代码：
    
```c
HASH-INSERT(T, k)
    i = 0
    repeat j = h(k, i)
        if T[j] == NIL
            then T[j] = k
            return j
        else i = i + 1
    until i = m
    error "hash table overflow"
```

对于开放地址的查找，很显然按照其探查顺序去查找就可以，直到找到相等的key。伪
代码：

```c
HASH-SEARCH(T, k)
    i = 0
    repeat j = h(k, i)
        if T[j] == k
            then return j
        i = i + 1
    until T[j] == NIL or i == m
    return NIL
```

需要注意的是，对于一个开放地址的哈希表，如果要从中删除一个元素，我们不能简单地将存放该元素的位置设置为NIL(用以表示空)，因为如此一来，所有原来因为该位置被占，而存储到其它位置的元素将不能再找到。例如，有一key为k的元素的探查序列为{1,5,6,2,8,3,…},被存储在位置8，假如我们将存储位置2设置为空，那么在对k进行查找时，我们依次查找1,5,6,2位置，但是因为2为空，程序任务已经查找完成——因为开放地址法总是将元素存储在第一个可以存储的位置的嘛——查找到2终止。要解决这个问题，我们应当将被删除元素的位置设置为“已删除”，而不是“空”。这样我们通过小小修改一下插入程序的代码使之能够在标记为“已删除”的位置插入元素就可以了。

### 开放地址的三种探查方式

#### 线性探查（Linear Probing）

线性探查很简单，实际上就是一种遍历的方式来探查可用的位置。哈希函数为：
*h*(*k*,*i*) = (*h*'(*k*) + *i*) mod *m* 其中*h'(k)*
称为辅助哈希函数。因为第一次探查的位置决定了整个探查顺序，所以所有的key最多只
可能有m个探查顺序，可见发生碰撞的概率不小。

线性探查易于实现，但是随着时间的推移，哈希表中被占用的位置越多，连续被占用的位
置也越来越多，碰撞的几率会大大提升，查找的平均时间将会大大增加。这种现象叫做
primary clustering（主要聚集？应该叫扎堆现象比较合适，暂定将primary clustering翻
译为“首要扎堆现象”）。

#### 二次探查（Quadratic probing）

二次探查函数形如\\(h(h('k') + c_{1}i + c_{2}i^2) \bmod m\\),与一次探查类似，
首次探查的位置决定了整个探查的顺序，因此对于所有的key也只可能最多用到m种探查顺
序，与一次相比的探查比较的好处在于，它的偏移量不是一个常数，而是由一个二次方程
决定，这样很大程度上避免了一次探查的首要扎堆现象，所以把二次探查这种现象称之为
次要扎堆现象（secondary clustering）吧。但是要想填满整个哈希表的话，那么在
\\(c_i, c_2\\)的选择上就要斟酌一番了。

#### 双重哈希（Double hashing）

注意！CLRS开场便说：双重哈希提供最好的方法之一给开放地址法。其函数形如：
\\( h(k, i) = (h_1(k) + ih_2(k)) \bmod m \\),它有两个辅助函数\\( h_i\\)和
\\(h_2\\)。双重哈希带来的好处是初始探查位置不能决定整个探查序列，因此双重哈希将
能使用到\\(O(m^2)\\)中探查序列，比之线性探查和二次探查的m种强了很多。但要注意的
一点是，要使探查序列能包含整个哈希表，\\(h_2\\)应当与表的大小m互质。两种使之互
质的方法是：

1.  使m为一个质数，\\(h_2\\)总产生比m小的正整数；
2.  取m为2的幂，而\\(h_2\\)总产生质数。

### 完全哈希表

完全哈希是指在最坏情况下，内存访问次数为O(1)。完全哈希采用二级结构，每一级上都采用
全域散列。其实犹如用链表解决碰撞的哈希表那样，只不过完全哈希不是使用链表而是使用一
个小的哈希表来实现，且保证在小的哈希表上不发生碰撞。

关于完全哈希尚有疑惑,不记录太多，以免误人，亦免自误。

[links]: http://www.roading.org/images/2011-11/image_thumb1.png
