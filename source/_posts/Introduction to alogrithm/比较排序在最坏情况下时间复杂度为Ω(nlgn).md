---
title: 比较排序在最坏情况下时间复杂度为Ω(nlgn)
date: 2011-9-27 23:00:00
categories: Introduction to Algorithm -third edition
tags: 
    - 8.1 Lower bounds for sorting
    - 算法导论
    - 比较排序  
override_permailink: /algorithm/introductiontoalgorithm/算法导论-第八章（1）-比较排序在最坏情况下时间
---

### 1.什么是比较排序?

之前的排序算法，包括插入排序，合并排序（归并排序），堆排序，快速排序等有 一个共同特点——这些排序算法都是基于比较元素来决定其相对位置的，我们称这种 排序算法为比较排序。

### 2.比较排序只关注比较结果

在比较排序中我们不检查元素的值，也不从其他渠道来获取其循序信息，也就是说， 对于比较排序，我们仅仅只关注其比较的结果，而并不理会进行比较的元素其本身 的值，或者任何其他能体现其相对位置的其它信息。

### 3.对n个元素进行排序，所有的比较排序算法在最坏情况下的复杂度为Ω(nlgn)

我们使用判定树（decision tree）来证明。假设有一组三个元素的序列,我们用1， 2，3来分别表示这三个元素，我们基于比较来对它排序，可以有下面的判定树：

![](http://www.roading.org/images/2011-09/wps_clip_image-1112_thumb.png)

不难发现，判定树的叶子表示了三个元素的所有可能排列。另外，用比较排序对这 三个元素进行排序的话，你总可以找到一条路径来表示它的整个比较过程。（需要 注意的是，1并不表示它代表第一个元素，它可以代表三个元素中任意一个。2，3也 相同。但是1，2，3不指向相同元素）。显然最坏情况下的复杂度即是判定树的高。

假设用比较排序对N个元素进行排序，它的判定树高为H,叶子数目为L。显然\\(L \leq 2^H \\)，然而\\( N≤LN≤L1 \\)。所以 \\( N!≤L≤2H \\)可化为：\\( H≥lg(N!)=Ω(N∗lgN) \\)。

是考虑到原文这一句：Because each of the N! permutation appears as areachable leaf.我觉得作者的意思着重于用N！来表示N个元素的所有可能排列，但是N个元素的所 有可能排列实际上是小于等于N！的，因为在N个元素中有可能有相等的元素。